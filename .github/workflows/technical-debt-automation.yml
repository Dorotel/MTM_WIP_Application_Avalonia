name: Technical Debt Auto-Creation

on:
  schedule:
    # Every Friday at 3 PM UTC to review weekly technical debt
    - cron: '0 15 * * 5'
  push:
    branches: [master, main]
    paths:
      - '**/*.cs'
      - '**/*.axaml'
      - '**/*.sql'
  workflow_dispatch:
    inputs:
      analysis_type:
        description: 'Type of technical debt analysis'
        required: true
        default: 'comprehensive'
        type: choice
        options:
          - comprehensive
          - code-complexity
          - documentation-debt
          - test-coverage
          - architecture-violations

jobs:
  analyze-technical-debt:
    name: Analyze and Create Technical Debt Issues
    runs-on: ubuntu-latest
    
    permissions:
      issues: write
      contents: read
      pull-requests: read
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for comprehensive analysis
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
        
    - name: Setup Node.js for Analysis Tools
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Install Analysis Tools
      run: |
        # Install code analysis tools
        dotnet tool install -g dotnet-outdated-tool
        npm install -g @eslint/js typescript
        
    - name: Analyze Code Complexity
      id: complexity
      run: |
        echo "Analyzing code complexity across MTM application..."
        
        # Find large methods (>50 lines)
        LARGE_METHODS=$(find . -name "*.cs" -type f -exec grep -n "public\|private\|protected" {} \; | \
          awk '/\{/{start=NR} /\}/{if(NR-start>50) print FILENAME":"start"-"NR}' | wc -l)
        
        # Find files with high cyclomatic complexity (approximation)
        COMPLEX_FILES=$(find . -name "*.cs" -type f -exec sh -c '
          if [ $(grep -c "if\|while\|for\|switch\|catch" "$1") -gt 15 ]; then
            echo "$1"
          fi
        ' _ {} \; | wc -l)
        
        # Find long parameter lists (>5 parameters)
        LONG_PARAMS=$(grep -r "public.*(" --include="*.cs" . | \
          grep -E '\([^)]*,[^)]*,[^)]*,[^)]*,[^)]*,' | wc -l)
        
        # Find duplicate code patterns
        DUPLICATE_BLOCKS=$(grep -r "TODO.*duplicate\|FIXME.*duplicate" --include="*.cs" . | wc -l)
        
        echo "large_methods=$LARGE_METHODS" >> $GITHUB_OUTPUT
        echo "complex_files=$COMPLEX_FILES" >> $GITHUB_OUTPUT
        echo "long_params=$LONG_PARAMS" >> $GITHUB_OUTPUT
        echo "duplicate_blocks=$DUPLICATE_BLOCKS" >> $GITHUB_OUTPUT
        
    - name: Analyze Documentation Debt
      id: documentation
      run: |
        echo "Analyzing documentation debt..."
        
        # Find ViewModels without XML documentation
        UNDOC_VIEWMODELS=$(find ./ViewModels -name "*.cs" -type f -exec grep -L "/// <summary>" {} \; | wc -l)
        
        # Find Services without XML documentation  
        UNDOC_SERVICES=$(find ./Services -name "*.cs" -type f -exec grep -L "/// <summary>" {} \; | wc -l)
        
        # Find public methods without documentation
        UNDOC_METHODS=$(grep -r "public.*(" --include="*.cs" ./ViewModels ./Services | \
          grep -v "/// <summary>" -A5 -B5 | grep "public.*(" | wc -l)
        
        # Find README files that need updates
        OLD_READMES=$(find . -name "README*" -type f -mtime +30 | wc -l)
        
        # Check for missing stored procedure documentation
        STORED_PROCS=$(grep -r "ExecuteDataTableWithStatus" --include="*.cs" . | \
          grep -o '"[^"]*"' | grep -E "(Get|Add|Update|Delete)" | sort -u | wc -l)
        DOCUMENTED_PROCS=$(find . -name "*.md" -exec grep -l "stored.*procedure" {} \; | \
          xargs grep -h "stored.*procedure" | wc -l)
        UNDOC_PROCS=$((STORED_PROCS - DOCUMENTED_PROCS))
        
        echo "undoc_viewmodels=$UNDOC_VIEWMODELS" >> $GITHUB_OUTPUT
        echo "undoc_services=$UNDOC_SERVICES" >> $GITHUB_OUTPUT  
        echo "undoc_methods=$UNDOC_METHODS" >> $GITHUB_OUTPUT
        echo "old_readmes=$OLD_READMES" >> $GITHUB_OUTPUT
        echo "undoc_procs=$UNDOC_PROCS" >> $GITHUB_OUTPUT
        
    - name: Analyze Test Coverage Debt
      id: testing
      run: |
        echo "Analyzing test coverage debt..."
        
        # Count total testable classes (ViewModels, Services)
        TOTAL_CLASSES=$(find ./ViewModels ./Services -name "*.cs" -type f | wc -l)
        
        # Count existing test files
        TEST_FILES=$(find . -name "*Test*.cs" -o -name "*Tests.cs" | wc -l)
        
        # Find ViewModels without corresponding tests
        UNTESTED_VMS=0
        for vm in $(find ./ViewModels -name "*.cs" -type f); do
          basename=$(basename "$vm" .cs)
          if ! find . -name "*${basename}*Test*.cs" | grep -q .; then
            UNTESTED_VMS=$((UNTESTED_VMS + 1))
          fi
        done
        
        # Find Services without corresponding tests
        UNTESTED_SERVICES=0
        for service in $(find ./Services -name "*.cs" -type f); do
          basename=$(basename "$service" .cs)
          if ! find . -name "*${basename}*Test*.cs" | grep -q .; then
            UNTESTED_SERVICES=$((UNTESTED_SERVICES + 1))
          fi
        done
        
        # Calculate approximate test coverage
        TESTED_CLASSES=$((TOTAL_CLASSES - UNTESTED_VMS - UNTESTED_SERVICES))
        if [ $TOTAL_CLASSES -gt 0 ]; then
          TEST_COVERAGE=$(( (TESTED_CLASSES * 100) / TOTAL_CLASSES ))
        else
          TEST_COVERAGE=0
        fi
        
        echo "total_classes=$TOTAL_CLASSES" >> $GITHUB_OUTPUT
        echo "test_files=$TEST_FILES" >> $GITHUB_OUTPUT
        echo "untested_vms=$UNTESTED_VMS" >> $GITHUB_OUTPUT
        echo "untested_services=$UNTESTED_SERVICES" >> $GITHUB_OUTPUT
        echo "test_coverage=$TEST_COVERAGE" >> $GITHUB_OUTPUT
        
    - name: Analyze Architecture Violations
      id: architecture
      run: |
        echo "Analyzing architecture violations..."
        
        # Find direct database calls (should use stored procedures only)
        DIRECT_SQL=$(grep -r "new MySqlCommand\|CommandText\|ExecuteReader\|ExecuteNonQuery" --include="*.cs" . | \
          grep -v "Helper_Database_StoredProcedure" | wc -l)
        
        # Find ViewModels not using MVVM Community Toolkit patterns
        NON_TOOLKIT_VMS=$(find ./ViewModels -name "*.cs" -type f -exec grep -L "ObservableObject\|RelayCommand" {} \; | wc -l)
        
        # Find Views with business logic in code-behind
        LOGIC_IN_VIEWS=$(find ./Views -name "*.axaml.cs" -type f -exec sh -c '
          if [ $(wc -l < "$1") -gt 20 ]; then
            echo "$1"
          fi
        ' _ {} \; | wc -l)
        
        # Find Services not using dependency injection properly
        NON_DI_SERVICES=$(grep -r "new.*Service" --include="*.cs" ./ViewModels ./Services | \
          grep -v "DependencyInjection\|IServiceCollection" | wc -l)
        
        # Find hardcoded connection strings or configurations
        HARDCODED_CONFIGS=$(grep -r "server=\|database=\|uid=\|password=" --include="*.cs" . | \
          grep -v "appsettings\|configuration" | wc -l)
        
        echo "direct_sql=$DIRECT_SQL" >> $GITHUB_OUTPUT
        echo "non_toolkit_vms=$NON_TOOLKIT_VMS" >> $GITHUB_OUTPUT
        echo "logic_in_views=$LOGIC_IN_VIEWS" >> $GITHUB_OUTPUT
        echo "non_di_services=$NON_DI_SERVICES" >> $GITHUB_OUTPUT
        echo "hardcoded_configs=$HARDCODED_CONFIGS" >> $GITHUB_OUTPUT
        
    - name: Calculate Technical Debt Score
      id: debt_score
      run: |
        # Calculate overall technical debt score (0-100, lower is better)
        COMPLEXITY_SCORE=$(( (${{ steps.complexity.outputs.large_methods }} + ${{ steps.complexity.outputs.complex_files }}) * 2 ))
        DOC_SCORE=$(( (${{ steps.documentation.outputs.undoc_viewmodels }} + ${{ steps.documentation.outputs.undoc_services }}) * 3 ))
        TEST_SCORE=$(( (100 - ${{ steps.testing.outputs.test_coverage }}) ))
        ARCH_SCORE=$(( (${{ steps.architecture.outputs.direct_sql }} + ${{ steps.architecture.outputs.non_toolkit_vms }}) * 4 ))
        
        TOTAL_DEBT_SCORE=$(( (COMPLEXITY_SCORE + DOC_SCORE + TEST_SCORE + ARCH_SCORE) / 4 ))
        
        # Determine debt level
        if [ $TOTAL_DEBT_SCORE -lt 20 ]; then
          DEBT_LEVEL="low"
          DEBT_PRIORITY="low"
        elif [ $TOTAL_DEBT_SCORE -lt 40 ]; then
          DEBT_LEVEL="medium"
          DEBT_PRIORITY="medium"
        elif [ $TOTAL_DEBT_SCORE -lt 60 ]; then
          DEBT_LEVEL="high"
          DEBT_PRIORITY="high"
        else
          DEBT_LEVEL="critical"
          DEBT_PRIORITY="critical"
        fi
        
        echo "total_debt_score=$TOTAL_DEBT_SCORE" >> $GITHUB_OUTPUT
        echo "debt_level=$DEBT_LEVEL" >> $GITHUB_OUTPUT
        echo "debt_priority=$DEBT_PRIORITY" >> $GITHUB_OUTPUT
        
    - name: Create Code Complexity Issue
      if: steps.complexity.outputs.large_methods > 5 || steps.complexity.outputs.complex_files > 10
      uses: actions/github-script@v7
      with:
        script: |
          const { large_methods, complex_files, long_params, duplicate_blocks } = process.env;
          
          const issueBody = `## üîß Code Complexity Technical Debt
          
          This issue tracks code complexity debt identified in the MTM application codebase.
          
          ### Complexity Metrics
          | Metric | Count | Threshold | Status |
          |--------|-------|-----------|--------|
          | **Large Methods** | ${large_methods} | 5 | ${parseInt(large_methods) > 5 ? '‚ùå Exceeds' : '‚úÖ Good'} |
          | **Complex Files** | ${complex_files} | 10 | ${parseInt(complex_files) > 10 ? '‚ùå Exceeds' : '‚úÖ Good'} |
          | **Long Parameter Lists** | ${long_params} | 3 | ${parseInt(long_params) > 3 ? '‚ùå Exceeds' : '‚úÖ Good'} |
          | **Duplicate Code Blocks** | ${duplicate_blocks} | 0 | ${parseInt(duplicate_blocks) > 0 ? '‚ùå Found' : '‚úÖ None'} |
          
          ### Action Items
          - [ ] **Refactor Large Methods**: Break methods >50 lines into smaller, focused methods
          - [ ] **Simplify Complex Files**: Reduce cyclomatic complexity in files with >15 decision points
          - [ ] **Reduce Parameter Lists**: Use parameter objects or builder patterns for methods with >5 parameters
          - [ ] **Eliminate Duplicates**: Extract common code into reusable methods or utilities
          
          ### Refactoring Strategy
          1. **Identify Hotspots**: Focus on files with highest complexity scores
          2. **Extract Methods**: Break large methods into smaller, single-purpose methods
          3. **Extract Classes**: Split complex classes into multiple focused classes
          4. **Introduce Patterns**: Use design patterns to reduce complexity (Strategy, Factory, etc.)
          
          ### Acceptance Criteria
          - [ ] All methods reduced to <50 lines
          - [ ] All files have <15 decision points (if/while/for/switch/catch)
          - [ ] Parameter lists limited to 5 or fewer parameters
          - [ ] Duplicate code eliminated through extraction
          - [ ] Code review completed for all refactored components
          
          ### MVVM Community Toolkit Patterns
          Ensure refactored code follows established patterns:
          - Use \`[ObservableProperty]\` for properties
          - Use \`[RelayCommand]\` for commands
          - Maintain separation between ViewModels and business logic
          - Follow dependency injection patterns
          
          ---
          *Issue created by MTM Technical Debt Automation*  
          *Analysis Date: ${new Date().toISOString().split('T')[0]}*  
          *Debt Level: Code Complexity*
          `;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `üîß Code Complexity Technical Debt - ${new Date().toISOString().split('T')[0]}`,
            body: issueBody,
            labels: [
              'technical-debt', 
              'code-complexity', 
              'automated', 
              'priority:medium',
              'type:refactoring'
            ]
          });
      env:
        large_methods: ${{ steps.complexity.outputs.large_methods }}
        complex_files: ${{ steps.complexity.outputs.complex_files }}
        long_params: ${{ steps.complexity.outputs.long_params }}
        duplicate_blocks: ${{ steps.complexity.outputs.duplicate_blocks }}
        
    - name: Create Documentation Debt Issue
      if: steps.documentation.outputs.undoc_viewmodels > 3 || steps.documentation.outputs.undoc_services > 2
      uses: actions/github-script@v7
      with:
        script: |
          const { undoc_viewmodels, undoc_services, undoc_methods, old_readmes, undoc_procs } = process.env;
          
          const issueBody = `## üìö Documentation Technical Debt
          
          This issue tracks documentation debt across the MTM application.
          
          ### Documentation Gaps
          | Component | Missing Docs | Target | Status |
          |-----------|--------------|--------|--------|
          | **ViewModels** | ${undoc_viewmodels} | 0 | ${parseInt(undoc_viewmodels) === 0 ? '‚úÖ Complete' : '‚ùå Incomplete'} |
          | **Services** | ${undoc_services} | 0 | ${parseInt(undoc_services) === 0 ? '‚úÖ Complete' : '‚ùå Incomplete'} |
          | **Public Methods** | ${undoc_methods} | 0 | ${parseInt(undoc_methods) === 0 ? '‚úÖ Complete' : '‚ùå Incomplete'} |
          | **README Files** | ${old_readmes} outdated | 0 | ${parseInt(old_readmes) === 0 ? '‚úÖ Current' : '‚ö†Ô∏è Outdated'} |
          | **Stored Procedures** | ${undoc_procs} | 0 | ${parseInt(undoc_procs) === 0 ? '‚úÖ Complete' : '‚ùå Missing'} |
          
          ### Action Items
          
          #### XML Documentation
          - [ ] **ViewModels**: Add XML documentation to ${undoc_viewmodels} undocumented ViewModels
          - [ ] **Services**: Add XML documentation to ${undoc_services} undocumented Services
          - [ ] **Methods**: Document ${undoc_methods} public methods without summaries
          
          #### Technical Documentation
          - [ ] **Stored Procedures**: Document all ${undoc_procs} undocumented database procedures
          - [ ] **Architecture**: Create/update architecture decision records (ADRs)
          - [ ] **README Files**: Update ${old_readmes} outdated README files
          
          #### Code Comments
          - [ ] Add inline comments for complex business logic
          - [ ] Document non-obvious algorithm implementations
          - [ ] Explain MTM-specific manufacturing domain concepts
          
          ### Documentation Standards
          
          #### XML Documentation Template
          \`\`\`csharp
          /// <summary>
          /// Brief description of the class/method purpose
          /// </summary>
          /// <param name="paramName">Parameter description</param>
          /// <returns>Return value description</returns>
          /// <exception cref="ExceptionType">When this exception is thrown</exception>
          /// <example>
          /// Example usage of the method
          /// </example>
          \`\`\`
          
          #### Stored Procedure Documentation
          - **Purpose**: What business function does it serve?
          - **Parameters**: Input parameter descriptions and constraints
          - **Returns**: Output structure and meaning
          - **Example**: Sample usage from C# code
          
          ### Quality Gates
          - [ ] All new code requires XML documentation
          - [ ] PR template includes documentation checklist
          - [ ] Automated checks for missing documentation
          - [ ] Regular documentation review cycles
          
          ---
          *Issue created by MTM Technical Debt Automation*  
          *Analysis Date: ${new Date().toISOString().split('T')[0]}*  
          *Debt Level: Documentation*
          `;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `üìö Documentation Technical Debt - ${new Date().toISOString().split('T')[0]}`,
            body: issueBody,
            labels: [
              'technical-debt', 
              'documentation', 
              'automated', 
              'priority:medium',
              'type:documentation'
            ]
          });
      env:
        undoc_viewmodels: ${{ steps.documentation.outputs.undoc_viewmodels }}
        undoc_services: ${{ steps.documentation.outputs.undoc_services }}
        undoc_methods: ${{ steps.documentation.outputs.undoc_methods }}
        old_readmes: ${{ steps.documentation.outputs.old_readmes }}
        undoc_procs: ${{ steps.documentation.outputs.undoc_procs }}
        
    - name: Create Test Coverage Debt Issue
      if: steps.testing.outputs.test_coverage < 50
      uses: actions/github-script@v7
      with:
        script: |
          const { total_classes, test_files, untested_vms, untested_services, test_coverage } = process.env;
          
          const issueBody = `## üß™ Test Coverage Technical Debt
          
          This issue tracks test coverage debt in the MTM application.
          
          ### Test Coverage Analysis
          | Component | Count | Tested | Coverage |
          |-----------|--------|---------|----------|
          | **Total Classes** | ${total_classes} | ${parseInt(total_classes) - parseInt(untested_vms) - parseInt(untested_services)} | ${test_coverage}% |
          | **ViewModels** | - | ${parseInt(untested_vms)} untested | - |
          | **Services** | - | ${parseInt(untested_services)} untested | - |
          | **Test Files** | ${test_files} | - | - |
          
          ### Testing Strategy
          
          #### Priority 1: ViewModels Testing
          - [ ] Create unit tests for ${untested_vms} untested ViewModels
          - [ ] Test MVVM Community Toolkit property changes
          - [ ] Test RelayCommand implementations
          - [ ] Mock service dependencies
          
          #### Priority 2: Services Testing
          - [ ] Create unit tests for ${untested_services} untested Services
          - [ ] Test stored procedure integrations
          - [ ] Test error handling scenarios
          - [ ] Test dependency injection configurations
          
          #### Priority 3: Integration Testing
          - [ ] Test ViewModel-Service integration
          - [ ] Test database stored procedure calls
          - [ ] Test UI data binding scenarios
          - [ ] Test error handling workflows
          
          ### Test Framework Setup
          
          #### Recommended Testing Stack
          - **Test Framework**: xUnit or MSTest
          - **Mocking**: Moq for service mocking
          - **Assertions**: FluentAssertions for readable tests
          - **Coverage**: Coverlet for coverage analysis
          
          #### Test Patterns for MTM Application
          
          \`\`\`csharp
          [Test]
          public async Task ViewModel_PropertyChange_NotifiesCorrectly()
          {
              // Arrange
              var mockService = new Mock<IInventoryService>();
              var viewModel = new InventoryViewModel(mockService.Object);
              
              // Act
              viewModel.PartId = "TEST123";
              
              // Assert
              Assert.Equal("TEST123", viewModel.PartId);
              // Test property change notification if needed
          }
          \`\`\`
          
          ### Testing Guidelines
          
          #### ViewModel Testing
          - Test property change notifications
          - Test command execution and CanExecute logic
          - Test async command handling
          - Mock all service dependencies
          
          #### Service Testing
          - Test business logic implementation  
          - Test stored procedure parameter passing
          - Test error scenarios and exception handling
          - Test dependency injection scenarios
          
          ### Acceptance Criteria
          - [ ] Test coverage increased to >70%
          - [ ] All ViewModels have corresponding tests
          - [ ] All Services have unit tests
          - [ ] Integration tests for key workflows
          - [ ] Test CI/CD pipeline integration
          - [ ] Test results reporting in PRs
          
          ### Target Metrics
          - **Overall Coverage**: 70%+ (currently ${test_coverage}%)
          - **ViewModel Coverage**: 90%+
          - **Service Coverage**: 80%+
          - **Critical Path Coverage**: 95%+
          
          ---
          *Issue created by MTM Technical Debt Automation*  
          *Analysis Date: ${new Date().toISOString().split('T')[0]}*  
          *Debt Level: Test Coverage (${test_coverage}%)*
          `;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `üß™ Test Coverage Technical Debt - ${test_coverage}% Coverage`,
            body: issueBody,
            labels: [
              'technical-debt', 
              'testing', 
              'automated', 
              'priority:high',
              'type:quality'
            ]
          });
      env:
        total_classes: ${{ steps.testing.outputs.total_classes }}
        test_files: ${{ steps.testing.outputs.test_files }}
        untested_vms: ${{ steps.testing.outputs.untested_vms }}
        untested_services: ${{ steps.testing.outputs.untested_services }}
        test_coverage: ${{ steps.testing.outputs.test_coverage }}
        
    - name: Create Architecture Violation Issue
      if: steps.architecture.outputs.direct_sql > 0 || steps.architecture.outputs.non_toolkit_vms > 3
      uses: actions/github-script@v7
      with:
        script: |
          const { direct_sql, non_toolkit_vms, logic_in_views, non_di_services, hardcoded_configs } = process.env;
          
          const issueBody = `## üèõÔ∏è Architecture Violation Technical Debt
          
          This issue tracks violations of established MTM architecture patterns.
          
          ### Architecture Violations
          | Violation Type | Count | Threshold | Status |
          |----------------|-------|-----------|--------|
          | **Direct SQL Calls** | ${direct_sql} | 0 | ${parseInt(direct_sql) === 0 ? '‚úÖ Good' : '‚ùå Violations'} |
          | **Non-Toolkit ViewModels** | ${non_toolkit_vms} | 0 | ${parseInt(non_toolkit_vms) === 0 ? '‚úÖ Good' : '‚ùå Violations'} |
          | **Logic in Views** | ${logic_in_views} | 0 | ${parseInt(logic_in_views) === 0 ? '‚úÖ Good' : '‚ùå Violations'} |
          | **Non-DI Services** | ${non_di_services} | 0 | ${parseInt(non_di_services) === 0 ? '‚úÖ Good' : '‚ùå Violations'} |
          | **Hardcoded Configs** | ${hardcoded_configs} | 0 | ${parseInt(hardcoded_configs) === 0 ? '‚úÖ Good' : '‚ùå Violations'} |
          
          ### Critical Architecture Fixes
          
          #### 1. Database Access Pattern (${direct_sql} violations)
          **Problem**: Direct SQL calls instead of stored procedures
          **Solution**: Replace all direct SQL with \`Helper_Database_StoredProcedure.ExecuteDataTableWithStatus()\`
          
          \`\`\`csharp
          // ‚ùå WRONG: Direct SQL
          var command = new MySqlCommand("SELECT * FROM inventory", connection);
          
          // ‚úÖ CORRECT: Stored procedure
          var result = await Helper_Database_StoredProcedure.ExecuteDataTableWithStatus(
              connectionString,
              "inv_inventory_Get_All",
              parameters
          );
          \`\`\`
          
          #### 2. MVVM Community Toolkit Pattern (${non_toolkit_vms} violations)
          **Problem**: ViewModels not using MVVM Community Toolkit patterns
          **Solution**: Migrate to \`[ObservableObject]\` and \`[RelayCommand]\` attributes
          
          \`\`\`csharp
          // ‚ùå WRONG: Manual INotifyPropertyChanged
          public class OldViewModel : INotifyPropertyChanged { ... }
          
          // ‚úÖ CORRECT: MVVM Community Toolkit
          [ObservableObject]
          public partial class NewViewModel : BaseViewModel
          {
              [ObservableProperty]
              private string partId = string.Empty;
              
              [RelayCommand]
              private async Task SearchAsync() { ... }
          }
          \`\`\`
          
          #### 3. View Code-Behind (${logic_in_views} violations)
          **Problem**: Business logic in View code-behind files
          **Solution**: Move all logic to ViewModels, keep Views minimal
          
          #### 4. Dependency Injection (${non_di_services} violations)
          **Problem**: Manual service instantiation instead of DI
          **Solution**: Use constructor injection for all dependencies
          
          #### 5. Configuration Management (${hardcoded_configs} violations)
          **Problem**: Hardcoded connection strings and settings
          **Solution**: Use \`IConfiguration\` and \`appsettings.json\`
          
          ### Action Items
          - [ ] **Database**: Replace ${direct_sql} direct SQL calls with stored procedures
          - [ ] **ViewModels**: Migrate ${non_toolkit_vms} ViewModels to MVVM Community Toolkit
          - [ ] **Views**: Remove business logic from ${logic_in_views} View code-behind files
          - [ ] **Services**: Fix ${non_di_services} manual service instantiations
          - [ ] **Configuration**: Replace ${hardcoded_configs} hardcoded values with configuration
          
          ### Architecture Compliance Checklist
          - [ ] All database access uses stored procedures only
          - [ ] All ViewModels inherit from BaseViewModel and use MVVM Community Toolkit
          - [ ] All Views have minimal code-behind (InitializeComponent only)
          - [ ] All services use dependency injection
          - [ ] All configuration values come from appsettings.json
          - [ ] All services follow single responsibility principle
          - [ ] All error handling uses centralized ErrorHandling service
          
          ### Quality Gates
          - [ ] Architecture compliance checks in CI/CD
          - [ ] Code review checklist includes architecture patterns
          - [ ] Automated detection of architecture violations
          - [ ] Regular architecture review sessions
          
          ---
          *Issue created by MTM Technical Debt Automation*  
          *Analysis Date: ${new Date().toISOString().split('T')[0]}*  
          *Debt Level: Architecture Violations*
          `;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `üèõÔ∏è Architecture Violation Technical Debt - ${new Date().toISOString().split('T')[0]}`,
            body: issueBody,
            labels: [
              'technical-debt', 
              'architecture', 
              'automated', 
              'priority:high',
              'type:architecture'
            ]
          });
      env:
        direct_sql: ${{ steps.architecture.outputs.direct_sql }}
        non_toolkit_vms: ${{ steps.architecture.outputs.non_toolkit_vms }}
        logic_in_views: ${{ steps.architecture.outputs.logic_in_views }}
        non_di_services: ${{ steps.architecture.outputs.non_di_services }}
        hardcoded_configs: ${{ steps.architecture.outputs.hardcoded_configs }}
        
    - name: Generate Technical Debt Report
      id: report
      run: |
        cat > technical_debt_report.md << EOF
        # Technical Debt Analysis Report - $(date '+%Y-%m-%d')
        
        ## Overall Technical Debt Score: ${{ steps.debt_score.outputs.total_debt_score }}/100
        **Debt Level**: ${{ steps.debt_score.outputs.debt_level }}  
        **Priority**: ${{ steps.debt_score.outputs.debt_priority }}
        
        ## Detailed Analysis
        
        ### Code Complexity
        - **Large Methods**: ${{ steps.complexity.outputs.large_methods }}
        - **Complex Files**: ${{ steps.complexity.outputs.complex_files }}
        - **Long Parameter Lists**: ${{ steps.complexity.outputs.long_params }}
        - **Duplicate Blocks**: ${{ steps.complexity.outputs.duplicate_blocks }}
        
        ### Documentation Debt
        - **Undocumented ViewModels**: ${{ steps.documentation.outputs.undoc_viewmodels }}
        - **Undocumented Services**: ${{ steps.documentation.outputs.undoc_services }}
        - **Undocumented Methods**: ${{ steps.documentation.outputs.undoc_methods }}
        - **Undocumented Stored Procedures**: ${{ steps.documentation.outputs.undoc_procs }}
        
        ### Test Coverage
        - **Test Coverage**: ${{ steps.testing.outputs.test_coverage }}%
        - **Untested ViewModels**: ${{ steps.testing.outputs.untested_vms }}
        - **Untested Services**: ${{ steps.testing.outputs.untested_services }}
        
        ### Architecture Violations
        - **Direct SQL Calls**: ${{ steps.architecture.outputs.direct_sql }}
        - **Non-Toolkit ViewModels**: ${{ steps.architecture.outputs.non_toolkit_vms }}
        - **Logic in Views**: ${{ steps.architecture.outputs.logic_in_views }}
        - **Non-DI Services**: ${{ steps.architecture.outputs.non_di_services }}
        - **Hardcoded Configurations**: ${{ steps.architecture.outputs.hardcoded_configs }}
        
        ## Recommendations
        1. **Immediate**: Address architecture violations (stored procedures, MVVM patterns)
        2. **Short-term**: Improve test coverage to >70%
        3. **Medium-term**: Add comprehensive documentation
        4. **Long-term**: Refactor complex code and eliminate duplicates
        
        Generated by MTM Technical Debt Automation
        EOF
        
    - name: Upload Technical Debt Report
      uses: actions/upload-artifact@v4
      with:
        name: technical-debt-report-${{ github.sha }}
        path: technical_debt_report.md
        retention-days: 90
        
    - name: Summary
      run: |
        echo "=== Technical Debt Analysis Summary ==="
        echo "Analysis Type: ${{ github.event.inputs.analysis_type || 'comprehensive' }}"
        echo "Overall Debt Score: ${{ steps.debt_score.outputs.total_debt_score }}/100"
        echo "Debt Level: ${{ steps.debt_score.outputs.debt_level }}"
        echo "Issues Created: Based on violation thresholds"
        echo ""
        echo "Key Metrics:"
        echo "- Large Methods: ${{ steps.complexity.outputs.large_methods }}"
        echo "- Test Coverage: ${{ steps.testing.outputs.test_coverage }}%"
        echo "- Architecture Violations: ${{ steps.architecture.outputs.direct_sql }}"
        echo "- Documentation Gaps: ${{ steps.documentation.outputs.undoc_viewmodels }} ViewModels"
