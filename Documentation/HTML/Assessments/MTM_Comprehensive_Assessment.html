<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTM WIP Application - Comprehensive Knowledge Assessment</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .assessment-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .assessment-header {
            background: linear-gradient(135deg, #6a0dad 0%, #4a0880 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .assessment-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .assessment-description {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        .question-bank {
            padding: 30px;
        }

        .question-container {
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            overflow: hidden;
            transition: transform 0.2s ease;
        }

        .question-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .question-header {
            background: #6a0dad;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .question-number {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .difficulty-badge.beginner { background: #28a745; }
        .difficulty-badge.intermediate { background: #ffc107; color: #000; }
        .difficulty-badge.advanced { background: #fd7e14; }
        .difficulty-badge.expert { background: #dc3545; }

        .category-badge {
            background: #17a2b8;
            color: white;
        }

        .question-content {
            padding: 25px;
        }

        .question-title {
            color: #6a0dad;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .question-scenario {
            background: #e8f4fd;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .question-scenario strong {
            color: #17a2b8;
        }

        .question-text {
            margin-bottom: 20px;
        }

        .question-text strong {
            color: #6a0dad;
        }

        .answer-options {
            display: grid;
            gap: 10px;
        }

        .option {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .option:hover {
            border-color: #6a0dad;
            background: #f8f9ff;
        }

        .option input[type="radio"] {
            margin-right: 10px;
        }

        .option label {
            cursor: pointer;
            display: block;
            font-weight: 500;
        }

        .performance-rating {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.75rem;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            color: white;
        }

        .performance-best { background: #28a745; }
        .performance-good { background: #17a2b8; }
        .performance-fair { background: #ffc107; color: #000; }
        .performance-poor { background: #fd7e14; }
        .performance-worst { background: #dc3545; }

        .explanation {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 20px;
            margin-top: 15px;
        }

        .explanation h4 {
            color: #155724;
            margin-bottom: 10px;
        }

        .explanation p {
            margin-bottom: 8px;
        }

        .explanation strong {
            color: #155724;
        }

        .performance-analysis {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
        }

        .performance-analysis h5 {
            color: #856404;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .performance-ranking {
            color: #856404;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .submit-section {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
        }

        .submit-btn {
            background: linear-gradient(135deg, #6a0dad 0%, #4a0880 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
        }

        .mysql-version-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }

        .mysql-version-notice strong {
            color: #856404;
        }

        @media (max-width: 768px) {
            .assessment-header h1 {
                font-size: 2rem;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            body {
                padding: 10px;
            }

            .performance-rating {
                position: relative;
                top: auto;
                right: auto;
                display: block;
                margin-top: 8px;
                width: fit-content;
            }
        }
    </style>
</head>
<body>
    <div class="assessment-container">
        <header class="assessment-header">
            <h1>MTM WIP Application Knowledge Assessment</h1>
            <p class="assessment-description">Comprehensive evaluation of Avalonia MVVM architecture, MySQL 5.7 database patterns, service organization, and MTM-specific business logic implementation. This assessment covers real-world scenarios requiring deep understanding of .NET 8 patterns and manufacturing workflow requirements. Each option includes performance analysis.</p>
        </header>

        <div class="mysql-version-notice">
            <strong>Database Environment Notice:</strong> This assessment is specifically designed for MySQL 5.7 compatibility. All database questions, stored procedures, and SQL patterns reflect features available in MySQL 5.7. Modern MySQL features (JSON columns, CTEs, window functions) are not covered as they are not supported in the target environment.
        </div>
        
        <div class="question-bank">
            
            <!-- Question 1: Advanced Architecture -->
            <div class="question-container" data-difficulty="expert">
                <div class="question-header">
                    <span class="question-number">Question 1</span>
                    <span class="badge difficulty-badge expert">Expert</span>
                    <span class="badge category-badge">Architecture & Design</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">Service Organization and Dependency Injection Architecture</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> You're architecting a new module for MTM's quality control system that needs to integrate with the existing inventory system. The module requires error handling, database access, configuration management, and navigation services. Following MTM's established patterns, you need to organize services properly while maintaining the existing service file structure.</p>
                        
                        <p><strong>Current State:</strong> The project has ErrorHandling.cs, Configuration.cs, Navigation.cs, and Database.cs in the Services folder. Each file contains multiple related service classes following the category-based organization rule.</p>
                        
                        <p><strong>Requirement:</strong> Implement QualityControlService, QualityMetricsService, and QualityConfigurationService with proper dependency injection registration.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> Which approach correctly implements the MTM service organization rule while maintaining proper dependency injection patterns?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-poor">POOR</span>
                        <input type="radio" name="q1" id="q1a" value="a">
                        <label for="q1a">Create separate files QualityControlService.cs, QualityMetricsService.cs, and QualityConfigurationService.cs, each containing one service class, and register them individually in ServiceCollectionExtensions.cs</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q1" id="q1b" value="b">
                        <label for="q1b">Create a single QualityControl.cs file containing all three service classes and their related models, register them using services.AddMTMQualityServices() extension method following the established pattern</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-worst">WORST</span>
                        <input type="radio" name="q1" id="q1c" value="c">
                        <label for="q1c">Add the quality control services to the existing Configuration.cs file since they involve configuration management, and register them alongside existing configuration services</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q1" id="q1d" value="d">
                        <label for="q1d">Create QualityControl.cs for service implementations and separate interfaces in Services/Interfaces/Quality/ folder, register each service with different lifetimes (Singleton, Scoped, Transient)</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - MTM follows the SERVICE FILE ORGANIZATION RULE where all services of the same category MUST be in the same .cs file</p>
                    <p><strong>Why this matters:</strong> This approach maintains consistency with the established ErrorHandling.cs, Configuration.cs pattern while providing clean separation of concerns and proper DI registration patterns.</p>
                    <p><strong>Related concepts:</strong> Service lifetimes, extension method patterns, category-based organization</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Single extension method registration, optimal service resolution, minimal file I/O during compilation<br>
                            <strong>2. FAIR (D):</strong> Good organization but separate interfaces add complexity, mixed lifetimes can impact memory usage<br>
                            <strong>3. POOR (A):</strong> Multiple files increase compilation time, individual registrations slow container startup<br>
                            <strong>4. WORST (C):</strong> Violates SRP, creates tight coupling, makes services harder to resolve and test
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question 2: MySQL 5.7 Database Transaction Management -->
            <div class="question-container" data-difficulty="advanced">
                <div class="question-header">
                    <span class="question-number">Question 2</span>
                    <span class="badge difficulty-badge advanced">Advanced</span>
                    <span class="badge category-badge">MySQL 5.7 Database</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">MySQL 5.7 Stored Procedure Transaction Management and Error Handling</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> The inventory system needs to implement a "Bulk Part Transfer" operation that moves multiple parts between locations atomically using MySQL 5.7. If any single transfer fails, the entire operation must be rolled back. The operation involves calling inv_inventory_Move_Item for each part and logging each action.</p>
                        
                        <p><strong>Current Implementation:</strong> Individual transfers work via Helper_Database_StoredProcedure.ExecuteDataTableWithStatus(), but there's no batch transaction capability.</p>
                        
                        <p><strong>MySQL 5.7 Constraints:</strong> No JSON data type, no Common Table Expressions (CTEs), no window functions. Must use traditional MySQL 5.7 stored procedure patterns with DECLARE HANDLER and proper transaction management.</p>
                        
                        <p><strong>Business Requirement:</strong> Process 20+ parts in a single transaction with detailed error reporting for each failed item while maintaining audit trail integrity.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> What is the correct approach for implementing this requirement following MTM's database patterns and MySQL 5.7 capabilities?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-worst">WORST</span>
                        <input type="radio" name="q2" id="q2a" value="a">
                        <label for="q2a">Create a stored procedure using JSON arrays to pass part data and use JSON_EXTRACT() functions to process the batch (MySQL 5.7 compatible)</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q2" id="q2b" value="b">
                        <label for="q2b">Use TransactionScope in C# service layer to wrap multiple calls to Helper_Database_StoredProcedure.ExecuteDataTableWithStatus(), implementing comprehensive error collection and using ErrorHandling.HandleErrorAsync for user feedback</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-good">GOOD</span>
                        <input type="radio" name="q2" id="q2c" value="c">
                        <label for="q2c">Create a MySQL 5.7 stored procedure using a temporary table to hold part data, CURSOR loops for processing, and DECLARE HANDLER for error management with proper ROLLBACK statements</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q2" id="q2d" value="d">
                        <label for="q2d">Implement Entity Framework transactions with DbContext.Database.BeginTransaction() and call stored procedures through FromSqlRaw() methods</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - TransactionScope provides proper distributed transaction management while maintaining the established Helper_Database_StoredProcedure pattern</p>
                    <p><strong>Why this matters:</strong> This approach leverages existing stored procedures, maintains MTM's database access patterns, and provides comprehensive error handling through the established ErrorHandling service. Option A is incorrect because JSON functions are not available in MySQL 5.7.</p>
                    <p><strong>MySQL 5.7 Note:</strong> JSON data type and functions were introduced in MySQL 5.7.8, but the MTM environment may be using an earlier version. Option C could work but violates MTM's pattern of keeping transaction logic in the service layer.</p>
                    <p><strong>Related concepts:</strong> ACID transactions, distributed transactions, service layer responsibilities, error aggregation, MySQL 5.7 limitations</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Optimized connection pooling, parallel processing capability, efficient memory management with C# collections<br>
                            <strong>2. GOOD (C):</strong> Single database round-trip but CURSOR loops are slow in MySQL, limited error granularity<br>
                            <strong>3. FAIR (D):</strong> EF overhead adds latency, less efficient parameter handling, additional abstraction layer costs<br>
                            <strong>4. WORST (A):</strong> JSON functions not available in MySQL 5.7, would cause runtime failures and poor error handling
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question 3: MVVM and Data Binding -->
            <div class="question-container" data-difficulty="intermediate">
                <div class="question-header">
                    <span class="question-number">Question 3</span>
                    <span class="badge difficulty-badge intermediate">Intermediate</span>
                    <span class="badge category-badge">UI Development</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">Avalonia MVVM Patterns and Reactive Data Binding</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> You're implementing a real-time inventory monitoring view that displays part quantities across multiple locations. The view needs to update automatically when inventory changes occur, show validation errors, and handle loading states gracefully.</p>
                        
                        <p><strong>Requirements:</strong> Auto-complete dropdowns for part selection, real-time quantity updates, error state management, and loading indicators during data refresh operations.</p>
                        
                        <p><strong>Current Pattern:</strong> The project uses standard .NET patterns with INotifyPropertyChanged, BaseViewModel with SetProperty, and ICommand implementations (AsyncCommand/RelayCommand). ReactiveUI has been removed from the project.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> Which ViewModel implementation correctly follows MTM's established patterns for this reactive monitoring interface?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-worst">WORST</span>
                        <input type="radio" name="q3" id="q3a" value="a">
                        <label for="q3a">Use ReactiveObject and ReactiveCommand<Unit, Unit> with this.WhenActivated() for lifecycle management and this.RaiseAndSetIfChanged() for property notifications</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q3" id="q3b" value="b">
                        <label for="q3b">Inherit from BaseViewModel with INotifyPropertyChanged, use SetProperty() for change notifications, implement AsyncCommand for data operations, and use ObservableCollection<T> for real-time updates</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-poor">POOR</span>
                        <input type="radio" name="q3" id="q3c" value="c">
                        <label for="q3c">Create a plain class with manual PropertyChanged events, use Timer for periodic data refresh, and implement custom command classes inheriting from ICommand</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q3" id="q3d" value="d">
                        <label for="q3d">Use System.Reactive.Linq with Observable.Timer() for data updates, implement ReactiveCommand with RxApp.MainThreadScheduler for UI thread marshaling</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - MTM has removed ReactiveUI and now uses standard .NET patterns with BaseViewModel and established command infrastructure</p>
                    <p><strong>Why this matters:</strong> The project follows standard .NET patterns for better maintainability and team familiarity, while ObservableCollection provides built-in change notifications for real-time updates. Options A and D are incorrect because ReactiveUI has been completely removed from the project.</p>
                    <p><strong>Related concepts:</strong> INotifyPropertyChanged, ObservableCollection, Command pattern, async/await patterns, ReactiveUI removal</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Optimized SetProperty with equality checks, efficient ObservableCollection change notifications, lightweight command pattern<br>
                            <strong>2. FAIR (D):</strong> Reactive streams have overhead, additional dependencies, complex scheduling can impact UI responsiveness<br>
                            <strong>3. POOR (C):</strong> Timer polling wastes CPU cycles, manual event handling prone to memory leaks, no built-in change optimization<br>
                            <strong>4. WORST (A):</strong> ReactiveUI removed from project, would cause compilation errors and missing dependencies
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question 4: Business Logic and Transaction Types -->
            <div class="question-container" data-difficulty="intermediate">
                <div class="question-header">
                    <span class="question-number">Question 4</span>
                    <span class="badge difficulty-badge intermediate">Intermediate</span>
                    <span class="badge category-badge">Business Logic</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">MTM Transaction Type Logic and Operation Workflow</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> A manufacturing operator is processing parts through different workflow stages. Parts flow through operations "90" (receiving), "100" (inspection), "110" (production), and "120" (shipping). The system needs to determine the correct transaction type for inventory tracking.</p>
                        
                        <p><strong>User Actions:</strong> An operator manually adds 50 units to operation "90" (receiving inspection), then moves 45 units to operation "100" (production queue), and ships 40 units from operation "120".</p>
                        
                        <p><strong>Business Requirement:</strong> Each action must be recorded with the correct transaction type for accurate inventory reporting and compliance auditing.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> According to MTM's business logic patterns, how should transaction types be determined for each operator action?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q4" id="q4a" value="a">
                        <label for="q4a">Base transaction type on operation numbers: "90"="IN", "100"="TRANSFER", "110"="PRODUCTION", "120"="OUT"</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q4" id="q4b" value="b">
                        <label for="q4b">Base transaction type on user intent: Manual addition="IN", Movement between locations="TRANSFER", Shipping="OUT", regardless of operation numbers</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-poor">POOR</span>
                        <input type="radio" name="q4" id="q4c" value="c">
                        <label for="q4c">Use a single "PROCESS" transaction type for all operations and track workflow stage separately in the operation field</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-good">GOOD</span>
                        <input type="radio" name="q4" id="q4d" value="d">
                        <label for="q4d">Determine transaction type based on quantity changes: Positive quantity="IN", Negative quantity="OUT", Zero change="TRANSFER"</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - MTM's TransactionType business logic is based on user intent, not operation numbers which represent workflow steps</p>
                    <p><strong>Why this matters:</strong> Operation numbers like "90", "100", "110" are workflow steps, not transaction indicators. The actual business transaction depends on what the user is trying to accomplish.</p>
                    <p><strong>Related concepts:</strong> Business rule separation, user intent modeling, workflow vs. transaction concepts</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Direct user intent evaluation, minimal processing overhead, clear business logic separation, efficient rule engine<br>
                            <strong>2. GOOD (D):</strong> Simple mathematical comparison, but requires additional quantity calculation steps, potential for edge cases<br>
                            <strong>3. FAIR (A):</strong> Simple lookup table but tight coupling between operations and transactions, harder to maintain business rules<br>
                            <strong>4. POOR (C):</strong> Generic approach loses business intelligence, requires complex post-processing for reporting and analytics
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question 5: Error Handling Architecture -->
            <div class="question-container" data-difficulty="advanced">
                <div class="question-header">
                    <span class="question-number">Question 5</span>
                    <span class="badge difficulty-badge advanced">Advanced</span>
                    <span class="badge category-badge">Error Handling</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">Comprehensive Error Handling and User Experience</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> During a critical inventory update operation, multiple error conditions can occur: database connection timeout, invalid part ID, insufficient inventory, concurrent modification conflicts, and business rule violations. The system must provide meaningful feedback to users while maintaining detailed logging for troubleshooting.</p>
                        
                        <p><strong>Current Infrastructure:</strong> ErrorHandling.cs provides comprehensive error management with HandleErrorAsync method, user-friendly message conversion, and structured logging capabilities.</p>
                        
                        <p><strong>User Requirement:</strong> Operations staff need immediate, actionable feedback without technical jargon, while IT needs detailed diagnostic information for system maintenance.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> What is the correct approach for implementing comprehensive error handling that serves both user experience and diagnostic requirements?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-poor">POOR</span>
                        <input type="radio" name="q5" id="q5a" value="a">
                        <label for="q5a">Use try-catch blocks in ViewModels with MessageBox.Show() for immediate user feedback and Console.WriteLine() for logging diagnostic information</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q5" id="q5b" value="b">
                        <label for="q5b">Use ErrorHandling.HandleErrorAsync() throughout service layer to provide user-friendly messages via UI binding while maintaining detailed technical logging with structured data</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-worst">WORST</span>
                        <input type="radio" name="q5" id="q5c" value="c">
                        <label for="q5c">Implement custom exception types for each error scenario and let them bubble up to a global exception handler that displays technical error details to users</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q5" id="q5d" value="d">
                        <label for="q5d">Use Result<T> pattern with success/failure states, display error codes to users, and require manual error code lookup for troubleshooting</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - The ErrorHandling service provides centralized error management with user-friendly message conversion and comprehensive logging</p>
                    <p><strong>Why this matters:</strong> This approach separates user experience from technical diagnostics, provides consistent error handling across the application, and supports both immediate user needs and long-term maintenance requirements.</p>
                    <p><strong>Related concepts:</strong> Separation of concerns, user experience design, structured logging, centralized error management</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Asynchronous logging, efficient session caching, optimized message transformation, minimal UI thread blocking<br>
                            <strong>2. FAIR (D):</strong> Result pattern is fast but manual lookup adds user friction, potential for lookup table cache misses<br>
                            <strong>3. POOR (A):</strong> Synchronous MessageBox blocks UI thread, Console.WriteLine has poor performance, scattered error handling<br>
                            <strong>4. WORST (C):</strong> Exception propagation overhead, global handlers can be slow, technical errors confuse users and increase support load
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question 6: Performance and Data Loading -->
            <div class="question-container" data-difficulty="advanced">
                <div class="question-header">
                    <span class="question-number">Question 6</span>
                    <span class="badge difficulty-badge advanced">Advanced</span>
                    <span class="badge category-badge">Performance</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">AutoCompleteBox Performance and MySQL 5.7 Data Management</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> The InventoryTabView has AutoCompleteBox controls for Part IDs (5000+ items), Operations (20+ items), and Locations (50+ items). Users report slow typing response and excessive database calls. The Part ID autocomplete should show real-time data, while Operations and Locations are relatively static.</p>
                        
                        <p><strong>Current Behavior:</strong> Each keystroke triggers database queries against MySQL 5.7. Large datasets cause UI freezing. No caching mechanism exists for static data.</p>
                        
                        <p><strong>MySQL 5.7 Constraints:</strong> No native JSON support for complex queries, limited full-text indexing capabilities, and traditional MyISAM/InnoDB storage engines only.</p>
                        
                        <p><strong>Performance Requirement:</strong> Sub-200ms response time for autocomplete suggestions, minimize database load, maintain data freshness for dynamic content.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> Which optimization strategy correctly balances performance, data freshness, and user experience requirements within MySQL 5.7 constraints?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q6" id="q6a" value="a">
                        <label for="q6a">Load all data at application startup into static collections, use LINQ filtering for autocomplete suggestions, refresh data only on application restart</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q6" id="q6b" value="b">
                        <label for="q6b">Implement tiered caching: Operations/Locations cached for 1 hour with background refresh, Part IDs use debounced search with 300ms delay and MySQL LIMIT 50 with proper indexing on searchable columns</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-poor">POOR</span>
                        <input type="radio" name="q6" id="q6c" value="c">
                        <label for="q6c">Use MySQL 5.7 full-text search with MATCH AGAINST for Part ID queries, implement query result caching using MySQL query cache settings</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-worst">WORST</span>
                        <input type="radio" name="q6" id="q6d" value="d">
                        <label for="q6d">Implement pagination in AutoCompleteBox with 20 items per page, use infinite scrolling for large datasets, query database on each page load</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - Tiered caching approach recognizes that different data types have different volatility and performance requirements while working within MySQL 5.7 constraints</p>
                    <p><strong>Why this matters:</strong> This strategy optimizes based on data characteristics: static data is cached longer, dynamic data uses intelligent querying with debouncing and result limiting. MySQL 5.7's LIMIT clause with proper indexing provides efficient data retrieval without relying on newer features.</p>
                    <p><strong>MySQL 5.7 Note:</strong> Option C may not be optimal because full-text search in MySQL 5.7 has limitations compared to newer versions and may not be suitable for Part ID searches which are typically exact or prefix matches.</p>
                    <p><strong>Related concepts:</strong> Debouncing, query optimization, cache invalidation strategies, user experience optimization, MySQL 5.7 performance patterns</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Optimal cache hit ratios, reduced database load, debouncing prevents excessive queries, indexed LIMIT queries are very fast<br>
                            <strong>2. FAIR (A):</strong> Fast LINQ filtering but high memory usage, stale data issues, long startup times with large datasets<br>
                            <strong>3. POOR (C):</strong> MySQL 5.7 full-text search less efficient for Part IDs, query cache has limited effectiveness, index maintenance overhead<br>
                            <strong>4. WORST (D):</strong> Multiple database queries per user interaction, pagination overhead, poor autocomplete UX, constant network traffic
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question 7: Navigation and State Management -->
            <div class="question-container" data-difficulty="intermediate">
                <div class="question-header">
                    <span class="question-number">Question 7</span>
                    <span class="badge difficulty-badge intermediate">Intermediate</span>
                    <span class="badge category-badge">Navigation & State</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">MVVM Navigation Patterns and State Preservation</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> Users work with multiple inventory forms simultaneously: main inventory entry, advanced remove operations, and settings configuration. Each form maintains user input state and should preserve data when switching between forms. Users expect back/forward navigation and form state restoration.</p>
                        
                        <p><strong>Current Navigation:</strong> The application uses tab-based navigation with UserControl views. The Navigation.cs service provides basic navigation capabilities following MTM service organization patterns.</p>
                        
                        <p><strong>Business Requirement:</strong> Implement proper MVVM navigation that preserves form state, supports undo functionality, and maintains user workflow context.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> Which navigation architecture correctly implements MVVM patterns while preserving user state and supporting MTM's established service patterns?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-poor">POOR</span>
                        <input type="radio" name="q7" id="q7a" value="a">
                        <label for="q7a">Use Avalonia's built-in navigation with Frame and Page controls, store ViewModel state in static properties, implement custom serialization for state persistence</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q7" id="q7b" value="b">
                        <label for="q7b">Extend Navigation service to maintain ViewModel instance cache with INavigationState interface, use ApplicationStateService for cross-session persistence, implement navigation stack for back/forward functionality</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-worst">WORST</span>
                        <input type="radio" name="q7" id="q7c" value="c">
                        <label for="q7c">Create separate Windows for each form, use Window.ShowDialog() for modal navigation, store state in Window.DataContext and persist via Registry settings</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q7" id="q7d" value="d">
                        <label for="q7d">Implement navigation using UserControl.IsVisible properties, create singleton ViewModels for state preservation, use event aggregator for inter-ViewModel communication</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - This approach extends the existing Navigation service while leveraging ApplicationStateService and following established MTM patterns</p>
                    <p><strong>Why this matters:</strong> The solution maintains consistency with existing service architecture, provides proper separation of concerns, and uses established state management patterns while supporting complex navigation requirements.</p>
                    <p><strong>Related concepts:</strong> ViewModel lifecycle management, state serialization, service composition, navigation patterns</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Efficient ViewModel caching, minimal state serialization overhead, optimized navigation stack operations, leverages existing services<br>
                            <strong>2. FAIR (D):</strong> Singleton ViewModels save memory but can lead to state conflicts, visibility toggles are fast but limit layout flexibility<br>
                            <strong>3. POOR (A):</strong> Static properties create memory leaks, custom serialization overhead, Frame/Page navigation can be slow in Avalonia<br>
                            <strong>4. WORST (C):</strong> Multiple Windows consume excessive memory, modal dialogs block user workflow, Registry access is slow and unreliable
                        </div>
                    </div>
                </div>
            </div>

            <!-- Question 8: Testing and Quality Assurance -->
            <div class="question-container" data-difficulty="expert">
                <div class="question-header">
                    <span class="question-number">Question 8</span>
                    <span class="badge difficulty-badge expert">Expert</span>
                    <span class="badge category-badge">Testing & Quality</span>
                </div>
                
                <div class="question-content">
                    <h3 class="question-title">Comprehensive Testing Strategy for Complex Business Logic</h3>
                    <div class="question-scenario">
                        <p><strong>Scenario:</strong> You need to implement comprehensive testing for the inventory transfer system that involves MySQL 5.7 database operations, business rule validation, error handling, and UI state management. The system has complex interaction patterns between ViewModels, Services, and stored procedures.</p>
                        
                        <p><strong>Testing Requirements:</strong> Unit tests for business logic, integration tests for MySQL 5.7 database operations, UI testing for ViewModel interactions, and end-to-end testing for complete workflows.</p>
                        
                        <p><strong>Current Infrastructure:</strong> MTM patterns include service abstraction, dependency injection, and comprehensive error handling that should support testability. Database uses MySQL 5.7 with traditional stored procedures.</p>
                    </div>
                    <div class="question-text">
                        <p><strong>Question:</strong> Which testing architecture correctly addresses all testing requirements while supporting MTM's service organization and MySQL 5.7 database patterns?</p>
                    </div>
                </div>
                
                <div class="answer-options">
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-poor">POOR</span>
                        <input type="radio" name="q8" id="q8a" value="a">
                        <label for="q8a">Use NUnit with manual mock creation, test ViewModels directly against real MySQL 5.7 database, implement UI testing through Avalonia's automation framework with full application startup</label>
                    </div>
                    <div class="option" data-correct="true">
                        <span class="performance-rating performance-best">BEST</span>
                        <input type="radio" name="q8" id="q8b" value="b">
                        <label for="q8b">Implement layered testing: xUnit with Moq for service layer unit tests, MySQL TestContainers with 5.7 image for database integration tests, separate ViewModel tests with mocked services, and Avalonia.Headless for UI automation</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-worst">WORST</span>
                        <input type="radio" name="q8" id="q8c" value="c">
                        <label for="q8c">Create integration tests only using real MySQL 5.7 connections, implement UI testing through manual test scripts, use reflection to test private methods and internal state</label>
                    </div>
                    <div class="option" data-correct="false">
                        <span class="performance-rating performance-fair">FAIR</span>
                        <input type="radio" name="q8" id="q8d" value="d">
                        <label for="q8d">Use MSTest with custom test frameworks, create MySQL 5.7 test databases for each test method, implement UI testing through Windows automation APIs for Avalonia controls</label>
                    </div>
                </div>
                
                <div class="explanation" style="display: none;">
                    <h4>Explanation:</h4>
                    <p><strong>Correct Answer:</strong> B - Layered testing strategy provides appropriate isolation levels while supporting MTM's service abstraction patterns and MySQL 5.7 constraints</p>
                    <p><strong>Why this matters:</strong> This approach enables fast unit tests through proper mocking, reliable integration tests through containerized MySQL 5.7 databases (ensuring version compatibility), and comprehensive UI testing through Avalonia's headless capabilities, all while respecting the established architecture.</p>
                    <p><strong>MySQL 5.7 Note:</strong> Using TestContainers with the specific mysql:5.7 image ensures test database compatibility with the production environment, avoiding issues with newer MySQL features that might not be available.</p>
                    <p><strong>Related concepts:</strong> Test isolation, dependency injection in testing, containerized testing, UI automation patterns, MySQL version compatibility</p>
                    
                    <div class="performance-analysis">
                        <h5>ðŸš€ Performance Analysis:</h5>
                        <div class="performance-ranking">
                            <strong>1. BEST (B):</strong> Parallel test execution, fast mock-based unit tests, efficient containerized databases, headless UI testing with minimal overhead<br>
                            <strong>2. FAIR (D):</strong> MSTest framework overhead, database creation per test is slow, Windows automation APIs add latency and flakiness<br>
                            <strong>3. POOR (A):</strong> Manual mocking is error-prone and slow, real database dependencies make tests slow and brittle, full app startup per test<br>
                            <strong>4. WORST (C):</strong> Integration tests only are extremely slow, manual testing scales poorly, reflection-based testing breaks encapsulation and is fragile
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <div class="submit-section">
            <button class="submit-btn" onclick="showResults()">Show Results & Explanations</button>
        </div>
    </div>

    <script>
        function showResults() {
            const explanations = document.querySelectorAll('.explanation');
            explanations.forEach(explanation => {
                explanation.style.display = 'block';
            });
            
            // Scroll to top to review answers
            document.querySelector('.assessment-container').scrollIntoView({
                behavior: 'smooth'
            });
            
            // Update button text
            event.target.textContent = 'Review Complete';
            event.target.disabled = true;
        }

        // Add click handlers for options to provide immediate feedback
        document.querySelectorAll('.option').forEach(option => {
            option.addEventListener('click', function() {
                const input = this.querySelector('input[type="radio"]');
                input.checked = true;
                
                // Visual feedback
                const questionContainer = this.closest('.question-container');
                const allOptions = questionContainer.querySelectorAll('.option');
                allOptions.forEach(opt => opt.style.background = 'white');
                this.style.background = '#f8f9ff';
            });
        });
    </script>
</body>
</html>
