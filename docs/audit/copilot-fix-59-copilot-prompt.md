# Copilot Continuation Prompt - Complete RemoveTabView Implementation

> **Generated by MTM Audit System** - Version 1.0  
> **Target Branch**: copilot/fix-59  
> **Feature**: Complete RemoveTabView Implementation with Simplified Interface, Enhanced Testing Documentation, and Production-Ready Inventory Removal Functionality  
> **Gap Report Date**: December 9, 2025, 10:30 AM

## Context Summary

The RemoveTabView implementation is **85% complete** with excellent foundation work including:

- ‚úÖ **Professional UI Implementation**: 279-line RemoveTabView.axaml with complete DataGrid-centric layout
- ‚úÖ **Comprehensive ViewModel**: 1,061-line RemoveItemViewModel with full MVVM Community Toolkit patterns
- ‚úÖ **Perfect AXAML Syntax**: 100% Avalonia compliance with proper xmlns and DynamicResource bindings
- ‚úÖ **Strong Service Integration**: ISuggestionOverlayService, ISuccessOverlayService, IQuickButtonsService properly integrated
- ‚úÖ **Complete Theme Integration**: All MTM theme variants supported with professional styling

**Critical Gap**: The implementation lacks dedicated service abstraction for remove operations, violating MTM's service-oriented architecture pattern. Business logic is currently embedded in the 1,061-line ViewModel.

## üéØ Immediate Focus Areas (Critical Priority)

### 1. Missing IRemoveService Implementation (BLOCKING)
**Current Problem**: All business logic embedded in RemoveItemViewModel (1,061 lines) violates MTM service patterns.

**Required Solution**: Create dedicated service layer with proper abstraction:
```csharp
// Services/IRemoveService.cs
public interface IRemoveService
{
    Task<RemovalResult> ExecuteRemovalAsync(RemovalRequest request);
    Task<BatchRemovalResult> ExecuteBatchRemovalAsync(List<RemovalRequest> requests);
    Task<UndoResult> UndoLastRemovalAsync(string sessionId);
    Task<List<UndoHistoryItem>> GetUndoHistoryAsync(string sessionId);
    Task<ValidationResult> ValidateRemovalAsync(string partId, string operation, 
        string location, int quantity);
    
    // Event notifications
    event EventHandler<RemovalCompletedEventArgs> RemovalCompleted;
    event EventHandler<RemovalErrorEventArgs> RemovalError;
}
```

### 2. Batch Operations Missing (BLOCKING)
**Current Problem**: UI supports extended DataGrid selection but no backend batch processing.

**Required Implementation**:
```csharp
public async Task<BatchRemovalResult> ExecuteBatchRemovalAsync(List<RemovalRequest> requests)
{
    using var transaction = await _database.BeginTransactionAsync();
    
    try
    {
        var results = new List<RemovalResult>();
        foreach (var request in requests)
        {
            // Each removal creates "OUT" transaction
            var result = await ExecuteIndividualRemovalAsync(request);
            results.Add(result);
            
            await LogTransactionAsync(new TransactionLog
            {
                Type = "OUT", // ALWAYS OUT for removals
                PartId = request.PartId,
                Operation = request.Operation,
                Quantity = request.Quantity
            });
        }
        
        await transaction.CommitAsync();
        return new BatchRemovalResult { Success = true, ProcessedItems = results.Count };
    }
    catch (Exception ex)
    {
        await transaction.RollbackAsync();
        await Services.ErrorHandling.HandleErrorAsync(ex, "Batch removal failed");
        throw;
    }
}
```

### 3. Incomplete Undo System (HIGH PRIORITY)
**Current Problem**: Undo button exists but no session-based undo history management.

**Required Implementation**: Session-based undo with restoration logic.

## üèóÔ∏è MTM Architecture Requirements (MUST FOLLOW)

### Service-Oriented Architecture Pattern
```csharp
// CORRECT: Business logic in dedicated service
public class RemoveService : IRemoveService
{
    private readonly ILogger<RemoveService> _logger;
    private readonly IDatabaseService _databaseService;
    
    public RemoveService(ILogger<RemoveService> logger, IDatabaseService databaseService)
    {
        ArgumentNullException.ThrowIfNull(logger);
        ArgumentNullException.ThrowIfNull(databaseService);
        _logger = logger;
        _databaseService = databaseService;
    }
    
    // Business logic implementation
}

// ViewModel becomes thin orchestrator
[RelayCommand]
private async Task DeleteSelectedAsync()
{
    try
    {
        var requests = SelectedInventoryItems.Select(item => new RemovalRequest
        {
            PartId = item.PartId,
            Operation = item.Operation,
            Location = item.Location,
            Quantity = item.Quantity
        }).ToList();
        
        var result = await _removeService.ExecuteBatchRemovalAsync(requests);
        
        if (result.Success)
        {
            await _successOverlayService.ShowSuccessAsync(new SuccessMessage
            {
                Title = "Items Removed",
                Message = $"Successfully removed {result.ProcessedItems} items"
            });
        }
    }
    catch (Exception ex)
    {
        await Services.ErrorHandling.HandleErrorAsync(ex, "Delete operation failed");
    }
}
```

### Database Pattern Requirements
```csharp
// Use existing stored procedures with Helper_Database_StoredProcedure
var result = await Helper_Database_StoredProcedure.ExecuteDataTableWithStatus(
    connectionString,
    "inv_inventory_Remove_Item", // Use actual stored procedures
    new MySqlParameter[]
    {
        new("p_PartID", request.PartId),
        new("p_Operation", request.Operation),
        new("p_Location", request.Location),
        new("p_Quantity", request.Quantity)
    }
);

// ALL removals create "OUT" transactions
await LogTransactionAsync(new TransactionLog
{
    Type = "OUT", // ALWAYS OUT - operations are workflow steps, not transaction indicators
    PartId = request.PartId,
    Operation = request.Operation, // "90", "100", "110" are workflow steps
    Location = request.Location,
    Quantity = request.Quantity
});
```

### Service Registration Pattern
```csharp
// Extensions/ServiceCollectionExtensions.cs - Add this registration
public static IServiceCollection AddMTMServices(this IServiceCollection services, IConfiguration configuration)
{
    // Existing registrations...
    
    // Add Remove Service
    services.TryAddSingleton<IRemoveService, RemoveService>();
    
    return services;
}
```

## üîÑ Current Implementation Status

### Excellent Foundation (Keep These Patterns)
- **RemoveItemViewModel.cs**: Perfect MVVM Community Toolkit usage with `[ObservableProperty]` and `[RelayCommand]`
- **RemoveTabView.axaml**: Professional AXAML with proper Avalonia syntax and theme integration
- **Service Integration**: ISuggestionOverlayService, ISuccessOverlayService, IQuickButtonsService properly injected
- **Error Handling**: Services.ErrorHandling.HandleErrorAsync() pattern correctly implemented

### Files Requiring Modification
- **ViewModels/MainForm/RemoveItemViewModel.cs**: Extract business logic to RemoveService, keep as thin orchestrator
- **Extensions/ServiceCollectionExtensions.cs**: Add IRemoveService registration
- **Create New**: Services/RemoveService.cs and Services/IRemoveService.cs

## üìã Implementation Priority Order

### Phase 1: Service Infrastructure (4-6 hours)
1. **Create IRemoveService Interface** with all required method signatures
2. **Implement RemoveService Class** with business logic extracted from ViewModel
3. **Add Service Registration** in ServiceCollectionExtensions.cs
4. **Refactor RemoveItemViewModel** to use injected IRemoveService

### Phase 2: Batch Operations (3-4 hours)
1. **Implement Batch Processing** with atomic database transactions
2. **Add Progress Reporting** for large batch operations
3. **Implement Rollback Logic** for failed batch operations
4. **Add Comprehensive Error Handling** with user feedback

### Phase 3: Undo System (2-3 hours)
1. **Implement Session-Based Undo** tracking with UndoHistoryItem management
2. **Add Restoration Logic** creating IN transactions for undo operations
3. **Wire Undo Commands** to service methods in ViewModel

### Phase 4: Integration & Testing (1-2 hours)
1. **Test Service Integration** end-to-end with actual data
2. **Verify Transaction Types** - all removals create "OUT" transactions
3. **Test Batch Operations** with multiple selection scenarios
4. **Validate Error Handling** across all failure paths

## üö® Critical Compliance Checks

### Transaction Type Validation (MANDATORY)
```csharp
// ‚úÖ CORRECT: All removals are OUT transactions
public TransactionType DetermineTransactionType(RemovalOperation operation)
{
    return TransactionType.OUT; // Always OUT for removals
}

// ‚ùå WRONG: Don't use operation numbers for transaction types
// "90", "100", "110" are workflow steps, NOT transaction indicators
```

### Database Column Names (MANDATORY)
```csharp
// ‚úÖ CORRECT: Use documented column names
var userName = row["User"].ToString(); // Column is "User", Property is "User_Name"
var partId = row["PartID"].ToString(); // Column is "PartID", Property is "PartId"

// ‚ùå WRONG: Incorrect assumptions cause runtime errors
var userName = row["UserId"].ToString(); // FAILS - column is "User" not "UserId"
```

### Service Pattern Compliance
- ALL business logic MUST be in services, not ViewModels
- ViewModels are thin orchestrators only
- Use constructor injection with ArgumentNullException.ThrowIfNull
- Services registered with proper lifetime (singleton for shared state)

## üí° Code Examples for Current Context

### RemovalRequest Model (Create New)
```csharp
namespace MTM_WIP_Application_Avalonia.Models.RemoveService;

public class RemovalRequest
{
    public string PartId { get; set; } = string.Empty;
    public string Operation { get; set; } = string.Empty;
    public string Location { get; set; } = string.Empty;
    public int Quantity { get; set; }
    public string User { get; set; } = string.Empty;
    public string Reason { get; set; } = string.Empty;
    public bool IsCompleteRemoval { get; set; }
}

public class RemovalResult
{
    public bool Success { get; set; }
    public string Message { get; set; } = string.Empty;
    public string TransactionId { get; set; } = string.Empty;
    public RemovalSummary Summary { get; set; } = new();
}
```

### Service Implementation Template
```csharp
namespace MTM_WIP_Application_Avalonia.Services;

public class RemoveService : IRemoveService
{
    private readonly ILogger<RemoveService> _logger;
    private readonly IDatabaseService _databaseService;
    private readonly string _connectionString;
    
    public event EventHandler<RemovalCompletedEventArgs>? RemovalCompleted;
    public event EventHandler<RemovalErrorEventArgs>? RemovalError;
    
    public RemoveService(
        ILogger<RemoveService> logger,
        IDatabaseService databaseService)
    {
        ArgumentNullException.ThrowIfNull(logger);
        ArgumentNullException.ThrowIfNull(databaseService);
        
        _logger = logger;
        _databaseService = databaseService;
        _connectionString = databaseService.GetConnectionString();
    }
    
    public async Task<RemovalResult> ExecuteRemovalAsync(RemovalRequest request)
    {
        try
        {
            // Validation
            var validation = await ValidateRemovalAsync(request.PartId, request.Operation, 
                request.Location, request.Quantity);
            if (!validation.IsValid)
            {
                return new RemovalResult 
                { 
                    Success = false, 
                    Message = string.Join(", ", validation.ValidationErrors) 
                };
            }
            
            // Execute removal with stored procedure
            var parameters = new MySqlParameter[]
            {
                new("p_PartID", request.PartId),
                new("p_Operation", request.Operation),
                new("p_Location", request.Location),
                new("p_Quantity", request.Quantity),
                new("p_User", request.User)
            };
            
            var result = await Helper_Database_StoredProcedure.ExecuteDataTableWithStatus(
                _connectionString,
                "inv_inventory_Remove_Item",
                parameters
            );
            
            if (result.Status == 1)
            {
                // Log as OUT transaction
                await LogOutTransactionAsync(request);
                
                RemovalCompleted?.Invoke(this, new RemovalCompletedEventArgs(request));
                
                return new RemovalResult
                {
                    Success = true,
                    Message = "Item removed successfully",
                    TransactionId = Guid.NewGuid().ToString()
                };
            }
            else
            {
                return new RemovalResult
                {
                    Success = false,
                    Message = "Database operation failed"
                };
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error executing removal for {PartId}", request.PartId);
            RemovalError?.Invoke(this, new RemovalErrorEventArgs(ex, request));
            throw;
        }
    }
    
    private async Task LogOutTransactionAsync(RemovalRequest request)
    {
        var transactionParams = new MySqlParameter[]
        {
            new("p_PartID", request.PartId),
            new("p_Operation", request.Operation),
            new("p_TransactionType", "OUT"), // ALWAYS OUT for removals
            new("p_Location", request.Location),
            new("p_Quantity", request.Quantity),
            new("p_User", request.User)
        };
        
        await Helper_Database_StoredProcedure.ExecuteDataTableWithStatus(
            _connectionString,
            "inv_transaction_Add",
            transactionParams
        );
    }
}
```

## üîç Testing & Validation Checklist

### Service Integration Tests
- [ ] IRemoveService properly registered and injectable
- [ ] All service methods execute without errors
- [ ] Database operations create correct "OUT" transactions
- [ ] Error handling propagates correctly through service layers
- [ ] Event notifications fire correctly for success/error scenarios

### Business Logic Tests
- [ ] Single item removal creates "OUT" transaction
- [ ] Batch removal processes all items atomically
- [ ] Failed batch operations rollback correctly
- [ ] Undo operations create "IN" transactions for restoration
- [ ] All operations preserve operation numbers as workflow steps

### UI Integration Tests
- [ ] Extended DataGrid selection works with batch operations
- [ ] Keyboard shortcuts (F5, Escape, Delete, Ctrl+Z) functional
- [ ] CollapsiblePanel auto-behavior working correctly
- [ ] Success/error feedback displays properly
- [ ] Theme integration works across all MTM variants

## üöÄ Execution Instruction

**Priority**: Complete service abstraction layer first, then implement batch operations, followed by undo system integration.

**Architecture Focus**: Maintain MTM service-oriented patterns with thin ViewModels and comprehensive service layer.

**Database Focus**: Use existing stored procedures with Helper_Database_StoredProcedure.ExecuteDataTableWithStatus() pattern.

**Transaction Focus**: ALL removals create "OUT" transactions regardless of operation numbers.

---

#github-pull-request_copilot-coding-agent

@copilot Create the missing IRemoveService interface and RemoveService implementation following the MTM service-oriented architecture pattern. Extract the business logic from the 1,061-line RemoveItemViewModel into a dedicated service layer, implement batch removal operations with atomic database transactions, and add session-based undo functionality. Ensure ALL removal operations create "OUT" transactions and maintain the existing MVVM Community Toolkit patterns in the refactored ViewModel. Register the new service in ServiceCollectionExtensions and implement comprehensive error handling throughout the service layer.
