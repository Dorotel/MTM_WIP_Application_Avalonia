<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INavigationService - Technical Documentation</title>
    <link rel="stylesheet" href="../../../styles.css">
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üß≠ INavigationService - Technical Documentation</h1>
            <div class="nav-links">
                <a href="../../../PlainEnglish/FileDefinitions/Services/INavigationService.html" class="nav-link plain-english">üìñ Plain English Version</a>
                <a href="../../../index.html" class="nav-link">üè† Documentation Home</a>
            </div>
        </header>

        <main class="content">
            <!-- Interface Overview -->
            <section class="doc-section">
                <h2>üîß Interface Definition</h2>
                <div class="code-section">
                    <h3>INavigationService Interface Contract</h3>
                    <pre><code>namespace MTM_WIP_Application_Avalonia.Services.Interfaces
{
    /// &lt;summary&gt;
    /// Navigation service interface for MTM WIP Application Avalonia.
    /// Provides unified navigation capabilities for the MVVM architecture,
    /// supporting view management, state preservation, and access control.
    /// &lt;/summary&gt;
    public interface INavigationService
    {
        // Core Navigation Methods
        Task&lt;Result&gt; NavigateToAsync(string viewName, object parameter = null);
        Task&lt;Result&gt; NavigateToAsync&lt;T&gt;(object parameter = null) where T : class;
        Task&lt;Result&gt; GoBackAsync();
        Task&lt;Result&gt; GoForwardAsync();
        Task&lt;Result&gt; NavigateHomeAsync();

        // Navigation State Management
        bool CanGoBack { get; }
        bool CanGoForward { get; }
        string CurrentView { get; }
        Stack&lt;NavigationHistoryItem&gt; NavigationHistory { get; }
        
        // View Context Management
        Task&lt;Result&gt; PushContextAsync(string key, object value);
        Task&lt;Result&lt;T&gt;&gt; PopContextAsync&lt;T&gt;(string key);
        Task&lt;Result&lt;T&gt;&gt; GetContextAsync&lt;T&gt;(string key);
        Task&lt;Result&gt; ClearContextAsync();

        // Modal and Dialog Management
        Task&lt;Result&lt;TResult&gt;&gt; ShowDialogAsync&lt;TViewModel, TResult&gt;(TViewModel viewModel) 
            where TViewModel : class;
        Task&lt;Result&gt; ShowModalAsync&lt;TViewModel&gt;(TViewModel viewModel) where TViewModel : class;
        Task&lt;Result&gt; CloseModalAsync();

        // Advanced Navigation Features
        Task&lt;Result&gt; NavigateWithReplacementAsync(string viewName, object parameter = null);
        Task&lt;Result&gt; ClearNavigationStackAsync();
        Task&lt;Result&gt; NavigateToTabAsync(string tabName, int tabIndex);

        // Access Control Integration
        Task&lt;Result&lt;bool&gt;&gt; CanNavigateToAsync(string viewName, string userId);
        Task&lt;Result&gt; SetNavigationGuardAsync(string viewName, Func&lt;Task&lt;bool&gt;&gt; guard);

        // Event Notifications
        event EventHandler&lt;NavigationEventArgs&gt; NavigationStarted;
        event EventHandler&lt;NavigationEventArgs&gt; NavigationCompleted;
        event EventHandler&lt;NavigationErrorEventArgs&gt; NavigationFailed;
        event EventHandler&lt;ViewStateEventArgs&gt; ViewStateChanged;
    }
}</code></pre>
                </div>
            </section>

            <!-- Navigation Models -->
            <section class="doc-section">
                <h2>üìã Navigation Data Models</h2>
                
                <div class="model-section">
                    <h3>NavigationHistoryItem</h3>
                    <div class="code-section">
                        <pre><code>public class NavigationHistoryItem
{
    public string ViewName { get; set; }
    public Type ViewModelType { get; set; }
    public object Parameter { get; set; }
    public DateTime NavigatedAt { get; set; }
    public string UserId { get; set; }
    public Dictionary&lt;string, object&gt; ViewState { get; set; } = new();
    public string Title { get; set; }
    public string Description { get; set; }
}</code></pre>
                    </div>
                </div>

                <div class="model-section">
                    <h3>NavigationEventArgs</h3>
                    <div class="code-section">
                        <pre><code>public class NavigationEventArgs : EventArgs
{
    public string SourceView { get; set; }
    public string TargetView { get; set; }
    public object Parameter { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string UserId { get; set; }
    public bool CanCancel { get; set; } = true;
    public bool Cancel { get; set; } = false;
}</code></pre>
                    </div>
                </div>

                <div class="model-section">
                    <h3>ViewStateEventArgs</h3>
                    <div class="code-section">
                        <pre><code>public class ViewStateEventArgs : EventArgs
{
    public string ViewName { get; set; }
    public ViewState State { get; set; }
    public Dictionary&lt;string, object&gt; StateData { get; set; } = new();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}

public enum ViewState
{
    Loading,
    Loaded,
    Error,
    Closing,
    Closed
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Core Navigation Methods -->
            <section class="doc-section">
                <h2>üîÑ Core Navigation Methods</h2>
                
                <div class="method-detail">
                    <h3>NavigateToAsync(string viewName, object parameter = null)</h3>
                    <div class="method-info">
                        <p><strong>Purpose:</strong> Primary navigation method for moving between views by name.</p>
                        <div class="code-section">
                            <pre><code>public async Task&lt;Result&gt; NavigateToAsync(string viewName, object parameter = null)
{
    try
    {
        // Validate navigation permissions
        var currentUser = await _applicationState.GetCurrentUserAsync();
        if (!await CanNavigateToAsync(viewName, currentUser.Value?.UserId))
        {
            return Result.Failure("Access denied for the requested view");
        }

        // Trigger navigation started event
        var navArgs = new NavigationEventArgs
        {
            SourceView = CurrentView,
            TargetView = viewName,
            Parameter = parameter,
            UserId = currentUser.Value?.UserId
        };
        NavigationStarted?.Invoke(this, navArgs);

        if (navArgs.Cancel)
        {
            return Result.Failure("Navigation cancelled by event handler");
        }

        // Resolve target ViewModel
        var viewModel = _serviceProvider.GetService(GetViewModelType(viewName));
        if (viewModel == null)
        {
            return Result.Failure($"ViewModel for view '{viewName}' not found");
        }

        // Initialize ViewModel with parameter
        if (viewModel is INavigationAware navAware)
        {
            await navAware.OnNavigatedToAsync(parameter);
        }

        // Update current view and history
        AddToNavigationHistory(viewName, viewModel.GetType(), parameter);
        CurrentView = viewName;

        // Update UI
        await UpdateCurrentViewModelAsync(viewModel);

        // Trigger navigation completed event
        NavigationCompleted?.Invoke(this, navArgs);

        return Result.Success();
    }
    catch (Exception ex)
    {
        var errorArgs = new NavigationErrorEventArgs
        {
            TargetView = viewName,
            Error = ex,
            Timestamp = DateTime.UtcNow
        };
        NavigationFailed?.Invoke(this, errorArgs);
        
        return Result.Failure($"Navigation failed: {ex.Message}");
    }
}</code></pre>
                        </div>
                        <p><strong>Features:</strong></p>
                        <ul>
                            <li>Permission validation before navigation</li>
                            <li>Cancellable navigation events</li>
                            <li>Automatic ViewModel resolution and initialization</li>
                            <li>Navigation history management</li>
                            <li>Comprehensive error handling</li>
                        </ul>
                    </div>
                </div>

                <div class="method-detail">
                    <h3>NavigateToAsync&lt;T&gt;(object parameter = null)</h3>
                    <div class="method-info">
                        <p><strong>Purpose:</strong> Type-safe navigation using ViewModel types.</p>
                        <div class="code-section">
                            <pre><code>public async Task&lt;Result&gt; NavigateToAsync&lt;T&gt;(object parameter = null) where T : class
{
    var viewName = GetViewNameFromViewModel&lt;T&gt;();
    return await NavigateToAsync(viewName, parameter);
}

private string GetViewNameFromViewModel&lt;T&gt;() where T : class
{
    var viewModelName = typeof(T).Name;
    // Convert "InventoryViewModel" to "Inventory"
    return viewModelName.EndsWith("ViewModel") 
        ? viewModelName.Substring(0, viewModelName.Length - 9)
        : viewModelName;
}</code></pre>
                        </div>
                        <p><strong>Usage Example:</strong></p>
                        <div class="code-section">
                            <pre><code>// Type-safe navigation
await _navigationService.NavigateToAsync&lt;InventoryViewModel&gt;(inventoryFilter);

// Equivalent to:
await _navigationService.NavigateToAsync("Inventory", inventoryFilter);</code></pre>
                        </div>
                    </div>
                </div>

                <div class="method-detail">
                    <h3>GoBackAsync() / GoForwardAsync()</h3>
                    <div class="method-info">
                        <p><strong>Purpose:</strong> Browser-style navigation through history stack.</p>
                        <div class="code-section">
                            <pre><code>public async Task&lt;Result&gt; GoBackAsync()
{
    if (!CanGoBack)
    {
        return Result.Failure("Cannot go back - no previous view in history");
    }

    var previousItem = _navigationHistory.ElementAt(1); // Current is at index 0
    return await NavigateToAsync(previousItem.ViewName, previousItem.Parameter);
}

public async Task&lt;Result&gt; GoForwardAsync()
{
    if (!CanGoForward)
    {
        return Result.Failure("Cannot go forward - no forward view in history");
    }

    var forwardItem = _forwardHistory.Pop();
    return await NavigateToAsync(forwardItem.ViewName, forwardItem.Parameter);
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Context Management -->
            <section class="doc-section">
                <h2>üìù Context and State Management</h2>
                
                <div class="context-detail">
                    <h3>View Context Management</h3>
                    <div class="method-info">
                        <p><strong>Purpose:</strong> Preserve and share data between views during navigation.</p>
                        <div class="code-section">
                            <pre><code>private readonly Dictionary&lt;string, object&gt; _navigationContext = new();

public async Task&lt;Result&gt; PushContextAsync(string key, object value)
{
    try
    {
        _navigationContext[key] = value;
        
        // Optional: Persist to application state for session recovery
        await _applicationState.UpdateApplicationStateAsync($"NavContext_{key}", value);
        
        return Result.Success();
    }
    catch (Exception ex)
    {
        return Result.Failure($"Failed to push context: {ex.Message}");
    }
}

public async Task&lt;Result&lt;T&gt;&gt; GetContextAsync&lt;T&gt;(string key)
{
    try
    {
        if (_navigationContext.TryGetValue(key, out var value) && value is T typedValue)
        {
            return Result.Success(typedValue);
        }

        // Fallback: Try to load from application state
        var stateResult = await _applicationState.GetApplicationStateAsync();
        if (stateResult.IsSuccess && 
            stateResult.Value.TryGetValue($"NavContext_{key}", out var stateValue) && 
            stateValue is T typedStateValue)
        {
            _navigationContext[key] = typedStateValue; // Cache locally
            return Result.Success(typedStateValue);
        }

        return Result.Failure&lt;T&gt;($"Context key '{key}' not found or wrong type");
    }
    catch (Exception ex)
    {
        return Result.Failure&lt;T&gt;($"Failed to get context: {ex.Message}");
    }
}</code></pre>
                        </div>
                        <p><strong>Context Usage Patterns:</strong></p>
                        <ul>
                            <li>Preserve form data during navigation</li>
                            <li>Share selected items between related views</li>
                            <li>Maintain user preferences across sessions</li>
                            <li>Cache frequently accessed data</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Modal and Dialog Management -->
            <section class="doc-section">
                <h2>üñºÔ∏è Modal and Dialog Management</h2>
                
                <div class="modal-detail">
                    <h3>Dialog with Result Pattern</h3>
                    <div class="method-info">
                        <div class="code-section">
                            <pre><code>public async Task&lt;Result&lt;TResult&gt;&gt; ShowDialogAsync&lt;TViewModel, TResult&gt;(TViewModel viewModel) 
    where TViewModel : class
{
    try
    {
        // Create dialog window
        var dialogWindow = new DialogWindow
        {
            DataContext = viewModel,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            Owner = Application.Current.MainWindow
        };

        // Handle dialog result if ViewModel implements IDialogAware
        TResult result = default(TResult);
        if (viewModel is IDialogAware&lt;TResult&gt; dialogAware)
        {
            dialogAware.DialogResultReady += (sender, e) =>
            {
                result = e.Result;
                dialogWindow.DialogResult = true;
            };
        }

        // Show dialog modally
        var dialogResult = await dialogWindow.ShowDialog(Application.Current.MainWindow);

        if (dialogResult == true && result != null)
        {
            return Result.Success(result);
        }

        return Result.Failure&lt;TResult&gt;("Dialog was cancelled or no result provided");
    }
    catch (Exception ex)
    {
        return Result.Failure&lt;TResult&gt;($"Dialog failed: {ex.Message}");
    }
}

// Usage example:
var confirmResult = await _navigationService.ShowDialogAsync&lt;ConfirmDeleteViewModel, bool&gt;(
    new ConfirmDeleteViewModel { ItemName = "Part ABC123" });

if (confirmResult.IsSuccess && confirmResult.Value)
{
    // User confirmed deletion
    await DeleteItemAsync();
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="modal-detail">
                    <h3>Modal Management</h3>
                    <div class="method-info">
                        <div class="code-section">
                            <pre><code>public async Task&lt;Result&gt; ShowModalAsync&lt;TViewModel&gt;(TViewModel viewModel) where TViewModel : class
{
    try
    {
        // Create modal overlay
        var modalContainer = new ModalContainer
        {
            DataContext = viewModel,
            Background = new SolidColorBrush(Colors.Black) { Opacity = 0.5 }
        };

        // Add to main window's overlay layer
        var mainWindow = Application.Current.MainWindow as MainWindow;
        mainWindow?.ModalLayer.Children.Add(modalContainer);

        // Set current modal reference
        _currentModal = modalContainer;

        return Result.Success();
    }
    catch (Exception ex)
    {
        return Result.Failure($"Failed to show modal: {ex.Message}");
    }
}

public async Task&lt;Result&gt; CloseModalAsync()
{
    try
    {
        if (_currentModal != null)
        {
            var mainWindow = Application.Current.MainWindow as MainWindow;
            mainWindow?.ModalLayer.Children.Remove(_currentModal);
            _currentModal = null;
        }

        return Result.Success();
    }
    catch (Exception ex)
    {
        return Result.Failure($"Failed to close modal: {ex.Message}");
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Access Control Integration -->
            <section class="doc-section">
                <h2>üîí Access Control and Security</h2>
                
                <div class="security-detail">
                    <h3>Navigation Guards</h3>
                    <div class="method-info">
                        <div class="code-section">
                            <pre><code>private readonly Dictionary&lt;string, Func&lt;Task&lt;bool&gt;&gt;&gt; _navigationGuards = new();

public async Task&lt;Result&gt; SetNavigationGuardAsync(string viewName, Func&lt;Task&lt;bool&gt;&gt; guard)
{
    _navigationGuards[viewName] = guard;
    return Result.Success();
}

public async Task&lt;Result&lt;bool&gt;&gt; CanNavigateToAsync(string viewName, string userId)
{
    try
    {
        // Check basic authentication
        if (string.IsNullOrEmpty(userId))
        {
            return Result.Success(false); // Not authenticated
        }

        // Check custom navigation guard
        if (_navigationGuards.TryGetValue(viewName, out var guard))
        {
            var guardResult = await guard();
            if (!guardResult)
            {
                return Result.Success(false);
            }
        }

        // Check role-based permissions
        var user = await _applicationState.GetCurrentUserAsync();
        if (user.IsSuccess && user.Value != null)
        {
            var requiredPermission = GetRequiredPermissionForView(viewName);
            if (!string.IsNullOrEmpty(requiredPermission))
            {
                var hasPermission = await _authorizationService.HasPermissionAsync(
                    user.Value.UserId, requiredPermission);
                return hasPermission;
            }
        }

        return Result.Success(true); // Default: allow navigation
    }
    catch (Exception ex)
    {
        return Result.Failure&lt;bool&gt;($"Failed to check navigation permission: {ex.Message}");
    }
}

// Permission mapping for MTM views
private string GetRequiredPermissionForView(string viewName)
{
    return viewName switch
    {
        "UserManagement" => "admin.users.manage",
        "TransactionHistory" => "inventory.transactions.view",
        "InventoryManagement" => "inventory.manage",
        "AddItem" => "inventory.add",
        "RemoveItem" => "inventory.remove",
        "TransferItem" => "inventory.transfer",
        _ => null // No specific permission required
    };
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Avalonia Integration -->
            <section class="doc-section">
                <h2>üñ•Ô∏è Avalonia UI Integration</h2>
                
                <div class="integration-detail">
                    <h3>MVVM Pattern Integration</h3>
                    <div class="method-info">
                        <div class="code-section">
                            <pre><code>public class NavigationService : INavigationService, INotifyPropertyChanged
{
    private readonly IServiceProvider _serviceProvider;
    private readonly IApplicationStateService _applicationState;
    private object _currentViewModel;

    public object CurrentViewModel
    {
        get => _currentViewModel;
        private set
        {
            _currentViewModel = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(CurrentViewModel)));
        }
    }

    private async Task UpdateCurrentViewModelAsync(object viewModel)
    {
        // Cleanup previous ViewModel if disposable
        if (CurrentViewModel is IDisposable disposable)
        {
            disposable.Dispose();
        }

        // Set new ViewModel
        CurrentViewModel = viewModel;

        // Initialize if implements INavigationAware
        if (viewModel is INavigationAware navAware)
        {
            await navAware.OnNavigatedToAsync(null);
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="integration-detail">
                    <h3>View Registration and Resolution</h3>
                    <div class="method-info">
                        <div class="code-section">
                            <pre><code>// ViewService for dynamic view creation
public class ViewService
{
    private readonly Dictionary&lt;string, Type&gt; _viewMapping = new()
    {
        { "Inventory", typeof(InventoryView) },
        { "AddItem", typeof(AddItemView) },
        { "RemoveItem", typeof(RemoveItemView) },
        { "TransferItem", typeof(TransferItemView) },
        { "TransactionHistory", typeof(TransactionHistoryView) },
        { "UserManagement", typeof(UserManagementView) },
        { "MainWindow", typeof(MainWindowView) }
    };

    public Type GetViewType(string viewName)
    {
        return _viewMapping.TryGetValue(viewName, out var viewType) ? viewType : null;
    }

    public UserControl CreateView(string viewName)
    {
        var viewType = GetViewType(viewName);
        return viewType != null ? (UserControl)Activator.CreateInstance(viewType) : null;
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Performance Considerations -->
            <section class="doc-section">
                <h2>‚ö° Performance and Optimization</h2>
                
                <div class="performance-grid">
                    <div class="perf-item">
                        <h4>üöÄ View Caching</h4>
                        <p>Cache frequently used ViewModels to reduce creation overhead:</p>
                        <div class="code-section">
                            <pre><code>private readonly Dictionary&lt;string, object&gt; _viewModelCache = new();

private object GetOrCreateViewModel(string viewName)
{
    if (_viewModelCache.TryGetValue(viewName, out var cached))
    {
        return cached;
    }

    var viewModel = _serviceProvider.GetService(GetViewModelType(viewName));
    _viewModelCache[viewName] = viewModel;
    return viewModel;
}</code></pre>
                        </div>
                    </div>

                    <div class="perf-item">
                        <h4>üìä Navigation Analytics</h4>
                        <p>Track navigation performance and user patterns:</p>
                        <div class="code-section">
                            <pre><code>private void TrackNavigationMetrics(string sourceView, string targetView, TimeSpan duration)
{
    var metrics = new NavigationMetrics
    {
        SourceView = sourceView,
        TargetView = targetView,
        Duration = duration,
        Timestamp = DateTime.UtcNow,
        UserId = _currentUser?.UserId
    };

    _analyticsService.TrackEvent("Navigation", metrics);
}</code></pre>
                        </div>
                    </div>

                    <div class="perf-item">
                        <h4>üîÑ Memory Management</h4>
                        <p>Proper disposal of resources during navigation:</p>
                        <div class="code-section">
                            <pre><code>public void Dispose()
{
    // Dispose cached ViewModels
    foreach (var viewModel in _viewModelCache.Values.OfType&lt;IDisposable&gt;())
    {
        viewModel.Dispose();
    }

    // Clear context and history
    _navigationContext.Clear();
    _navigationHistory.Clear();
}</code></pre>
                        </div>
                    </div>

                    <div class="perf-item">
                        <h4>‚ö° Async Navigation</h4>
                        <p>Non-blocking navigation with progress indication:</p>
                        <div class="code-section">
                            <pre><code>public async Task&lt;Result&gt; NavigateToAsyncWithProgress(string viewName, 
    IProgress&lt;string&gt; progress = null)
{
    progress?.Report("Validating permissions...");
    var canNavigate = await CanNavigateToAsync(viewName, _currentUser?.UserId);
    
    if (!canNavigate.IsSuccess || !canNavigate.Value)
    {
        return Result.Failure("Navigation not permitted");
    }

    progress?.Report("Loading view...");
    // Continue with navigation...
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <footer class="footer">
            <p>üìç <strong>Navigation:</strong> 
                <a href="../../../PlainEnglish/FileDefinitions/Services/INavigationService.html">Plain English Guide</a> | 
                <a href="../../../index.html">Documentation Home</a> | 
                <a href="../../../Technical/index.html">Technical Index</a>
            </p>
        </footer>
    </div>
</body>
</html>